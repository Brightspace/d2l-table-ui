<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../d2l-icons/tier1-icons.html">
<link rel="import" href="../d2l-colors/d2l-colors.html">
<link rel="import" href="../d2l-image-action/d2l-image-action.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<!--
# D2L Scroll Wrapper

## Usage
```
	<link rel="import" href="d2l-scroll-wrapper.html">
	<style>
		#scroll-wrapper {
			--d2l-scroll-wrapper-h-scroll: {
				/* styles to apply when horizontal scrollbar appears */
			};

			/* Note that the left/right styles are applied at the same time if there is no scrollbar */
			--d2l-scroll-wrapper-left: {
				/* styles to apply when scrolled to the left */
			};
			--d2l-scroll-wrapper-right: {
				/* styles to apply when scrolled to the right */
			};

			--d2l-scroll-wrapper-action: {
				/* styles for the left/right action buttons */
			};

			--d2l-scroll-wrapper-action-hidden: {
				/* css to hide an action button */
			};

			--d2l-scroll-wrapper-action-visible: {
				/* css to show an action button */
			};

			--d2l-scroll-wrapper-action-start: {
				/* styles for the action button on the left (scrolls toward start) */
			};

			--d2l-scroll-wrapper-action-end: {
				/* styles for the action button on the right (scrolls toward end) */
			};
		}
	</style>
	The attributes are optional
	<div style="position: relative; width: 300px">
		<d2l-scroll-wrapper
			id="scroll-wrapper"
			style="width: 300px"
			scroll-duration="500"
			scroll-amount="0.8"
			start-icon="d2l-tier1:chevron-left"
			end-icon="d2l-tier1:chevron-right"
		>
			<div style="width: 350px">Stuff</div>
		</d2l-scroll-wrapper>
	</div>
```
@demo ./demo/d2l-scroll-wrapper.html Scroll Wrapper Demo
-->
<dom-module id="d2l-scroll-wrapper">
	<template strip-whitespace>
		<style>
			:host {
				display: block;
				overflow-x: auto;
				width: 100%;
				box-sizing: border-box;

				--d2l-scroll-wrapper-action-offset: -15px;

				--d2l-scroll-wrapper-action: {
					position: absolute;
					top: 10px;
					border-radius: 50%;
					border: 1px solid var(--d2l-scroll-wrapper-border-color);
					background-color: var(--d2l-scroll-wrapper-background-color);
					height: 18px;
					width: 18px;
					padding: 10px;
					box-sizing: content-box;
				};

				--d2l-scroll-wrapper-action-hidden: {
					display: none;
				};

				--d2l-scroll-wrapper-action-visible: {
					display: inline-block;
				};

				--d2l-scroll-wrapper-action-start: {
					right: auto;
					left: var(--d2l-scroll-wrapper-action-offset);
				};

				--d2l-scroll-wrapper-action-end: {
					right: var(--d2l-scroll-wrapper-action-offset);
					left: auto;
				};
			}

			:host([h-scrollbar]),
			:host-context([dir="rtl"])[scroll-rtl-reverse][h-scrollbar],
			:host-context([dir="rtl"])[scroll-rtl-negative][h-scrollbar] {
				@apply(--d2l-scroll-wrapper-h-scroll);
			}

			:host-context([dir="rtl"]):host([scroll-rtl-reverse][h-scrollbar]),
			:host-context([dir="rtl"]):host([scroll-rtl-negative][h-scrollbar]) {
				@apply(--d2l-scroll-wrapper-h-scroll);
			}

			:host-context([dir="rtl"])[scroll-rtl-reverse][scrollbar-right],
			:host-context([dir="rtl"])[scroll-rtl-negative][scrollbar-right],
			:host([scrollbar-left]) {
				@apply(--d2l-scroll-wrapper-left);
			}

			:host-context([dir="rtl"]):host([scroll-rtl-reverse][scrollbar-right]),
			:host-context([dir="rtl"]):host([scroll-rtl-negative][scrollbar-right]) {
				@apply(--d2l-scroll-wrapper-left);
			}

			:host-context([dir="rtl"])[scroll-rtl-reverse][scrollbar-left],
			:host-context([dir="rtl"])[scroll-rtl-negative][scrollbar-left],
			:host([scrollbar-right]) {
				@apply(--d2l-scroll-wrapper-right);
			}

			:host-context([dir="rtl"]):host([scroll-rtl-reverse][scrollbar-left]),
			:host-context([dir="rtl"]):host([scroll-rtl-negative][scrollbar-left]) {
				@apply(--d2l-scroll-wrapper-right);
			}

			.action,
			.rtl-action {
				@apply(--d2l-scroll-wrapper-action);
				@apply(--d2l-scroll-wrapper-action-hidden);
			}

			:host-context([dir="rtl"]) .rtl-end,
			.end {
				@apply(--d2l-scroll-wrapper-action-end);
			}

			:host-context([dir="rtl"]) .rtl-start,
			.start {
				@apply(--d2l-scroll-wrapper-action-start);
			}

			/* So, shady DOM doesn't like this syntax, but ShadowDOM needs it */
			:host-context([dir="rtl"])[h-scrollbar] .rtl-action,
			:host([h-scrollbar]) .action {
				@apply(--d2l-scroll-wrapper-action-visible);
			}

			:host-context([dir="rtl"]):host([h-scrollbar]) .rtl-action {
				@apply(--d2l-scroll-wrapper-action-visible);
			}

			/* Hide the start/end buttons depending on the state */
			:host-context([dir="rtl"])[scroll-rtl-default][scrollbar-right] .rtl-end,
			:host-context([dir="rtl"])[scroll-rtl-default][scrollbar-left] .rtl-start,
			:host-context([dir="rtl"])[scroll-rtl-reverse][scrollbar-right] .rtl-start,
			:host-context([dir="rtl"])[scroll-rtl-negative][scrollbar-right] .rtl-start,
			:host-context([dir="rtl"])[scroll-rtl-reverse][scrollbar-left] .rtl-end,
			:host-context([dir="rtl"])[scroll-rtl-negative][scrollbar-left] .rtl-end,
			:host-context([dir="rtl"]) .action,
			:host([scrollbar-right]) .end,
			:host([scrollbar-left]) .start {
				@apply(--d2l-scroll-wrapper-action-hidden);
			}

			:host-context([dir="rtl"]):host([scroll-rtl-default][scrollbar-right]) .rtl-end,
			:host-context([dir="rtl"]):host([scroll-rtl-default][scrollbar-left]) .rtl-start,
			:host-context([dir="rtl"]):host([scroll-rtl-reverse][scrollbar-right]) .rtl-start,
			:host-context([dir="rtl"]):host([scroll-rtl-negative][scrollbar-right]) .rtl-start,
			:host-context([dir="rtl"]):host([scroll-rtl-reverse][scrollbar-left]) .rtl-end,
			:host-context([dir="rtl"]):host([scroll-rtl-negative][scrollbar-left]) .rtl-end {
				@apply(--d2l-scroll-wrapper-action-hidden);
			}
		</style>
		<button class="start action" is="d2l-image-action" icon="[[startIcon]]" on-tap="handleTapBack"></button>
		<button class="end action" is="d2l-image-action" icon="[[endIcon]]" on-tap="handleTapForward"></button>
		<button class="rtl-end rtl-action" is="d2l-image-action" icon="[[startIcon]]" on-tap="handleTapForward"></button>
		<button class="rtl-start rtl-action" is="d2l-image-action" icon="[[endIcon]]" on-tap="handleTapBack"></button>
		<content></content>
	</template>
	<script>
		(function() {
			var getScrollType = (function() {
				var type;

				return function getScrollType() {
					if (type) {
						return type;
					}
					type = 'reverse';
					var div = document.createElement('div');
					div.innerHTML = '<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>';
					var definer = div.firstChild;
					document.body.appendChild(div);
					if (definer.scrollLeft > 0) {
						type = 'default';
					} else {
						definer.scrollLeft = 1;
						if (definer.scrollLeft === 0) {
							type = 'negative';
						}
					}
					document.body.removeChild(div);
					return type;
				};
			})();
			Polymer({
				is: 'd2l-scroll-wrapper',
				behaviors: [Polymer.IronResizableBehavior],

				properties: {
					/** Whether this element has a horizontal scrollbar */
					hScrollbar: {
						type: Boolean,
						reflectToAttribute: true,
						notify: true,
						value: false,
						readOnly: true
					},
					/** Whether this element is scrolled to the left */
					scrollbarLeft: {
						type: Boolean,
						reflectToAttribute: true,
						notify: true,
						value: false,
						readOnly: true
					},
					/** Whether this element is scrolled to the right */
					scrollbarRight: {
						type: Boolean,
						reflectToAttribute: true,
						notify: true,
						value: false,
						readOnly: true
					},
					/** The browser doesn't change scroll behavior on RTL. Use for styling buttons and applying mixins on RTL. See scrollRtlReverse and scrollRtlNegative */
					scrollRtlDefault: {
						type: Boolean,
						reflectToAttribute: true,
						notify: true,
						value: false,
						readOnly: true
					},
					/** The browser reverses the scrollLeft value on RTL */
					scrollRtlReverse: {
						type: Boolean,
						reflectToAttribute: true,
						notify: true,
						value: false,
						readOnly: true
					},
					/** The browser negates the scrollLeft value on RTL */
					scrollRtlNegative: {
						type: Boolean,
						reflectToAttribute: true,
						notify: true,
						value: false,
						readOnly: true
					},
					/** The duration for smooth scroll. 0 disables smooth scroll */
					scrollDuration: {
						type: Number,
						value: 500
					},
					/** The percentage of clientWidth to scroll by on clicking the action buttons */
					scrollAmount: {
						type: Number,
						value: 0.8
					},
					/** The icon to use for the start action button (left) */
					startIcon: {
						type: String,
						value: 'd2l-tier1:chevron-left'
					},
					/** The icon to use for the end action button (right) */
					endIcon: {
						type: String,
						value: 'd2l-tier1:chevron-right'
					}
				},

				listeners: {
					'iron-resize': 'checkScrollbar',
					'scroll': 'checkScrollThresholds'
				},

				handleTapBack: function() {
					var scrollDistance = this.clientWidth * this.scrollAmount;
					var isRTL = !!this.$$('[dir="rtl"] *');
					if (isRTL) {
						if (this.scrollRtlReverse) {
							this.scroll(scrollDistance - this.scrollLeft, true);
							return;
						} else if (this.scrollRtlNegative) {
							this.scroll(this.scrollLeft - scrollDistance, true);
							return;
						}
					}
					this.scroll(this.scrollLeft - scrollDistance, true);
				},

				handleTapForward: function() {
					var scrollDistance = this.clientWidth * this.scrollAmount;
					var isRTL = !!this.$$('[dir="rtl"] *');
					if (isRTL) {
						if (this.scrollRtlReverse) {
							this.scroll(this.scrollLeft - scrollDistance, true);
							return;
						} else if (this.scrollRtlNegative) {
							this.scroll(this.scrollLeft + scrollDistance, true);
							return;
						}
					}
					this.scroll(this.scrollLeft + scrollDistance, true);
				},

				scroll: function(left, smooth) {
					if (smooth && this.scrollDuration > 0) {
						var easingFn = function easeOutQuad(t, b, c, d) {
							t /= d;
							return -c * t * (t - 2) + b;
						};
						var animationId = Math.random();
						var duration = this.scrollDuration;
						var startTime = Date.now();
						var currentScrollLeft = this.scrollLeft;
						var deltaScrollLeft = left - currentScrollLeft;
						this._currentAnimationId = animationId;
						(function updateFrame() {
							var now = Date.now();
							var elapsedTime = now - startTime;
							if (elapsedTime > duration) {
								this.scrollLeft = left;
							} else if (this._currentAnimationId === animationId) {
								this.scrollLeft = easingFn(elapsedTime, currentScrollLeft, deltaScrollLeft, duration);
								requestAnimationFrame(updateFrame.bind(this));
							}
						}).call(this);
					} else {
						this.scrollLeft = left;
					}
				},

				ready: function() {
					this._setScrollRtlDefault(getScrollType() === 'default');
					this._setScrollRtlReverse(getScrollType() === 'reverse');
					this._setScrollRtlNegative(getScrollType() === 'negative');
				},

				attached: function() {
					// HACK. Edge doesn't update the offsetWidth/scrollWidth correctly
					// until after checkScrollThresholds has run. So run this twice
					this.async(this.checkScrollbar);
					this.async(this.checkScrollbar);
				},

				checkScrollbar: function() {
					this._setHScrollbar(this.offsetWidth !== this.scrollWidth);
					this.checkScrollThresholds();
				},

				checkScrollThresholds: function() {
					var lowerScrollValue = this.scrollWidth - this.offsetWidth - Math.abs(this.scrollLeft);
					this._setScrollbarLeft(this.scrollLeft === 0);
					this._setScrollbarRight(lowerScrollValue <= 0);
				}
			});
		})();
	</script>
</dom-module>
